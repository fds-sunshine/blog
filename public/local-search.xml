<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一、zookeeper入门</title>
    <link href="/fds-sunshine.github.io/2022/03/25/zookeeper/zookeeper%E5%85%A5%E9%97%A8/"/>
    <url>/fds-sunshine.github.io/2022/03/25/zookeeper/zookeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言<br/></h1><p>在此刻的我并不知道zookeeper是什么，我听到zookeeper的第一感觉就是这家伙是啥啊，对的，前言就这么短，因为我也不知道它是啥，也没怎么用。</p><h1 id="2-ZooKeeper介绍"><a href="#2-ZooKeeper介绍" class="headerlink" title="2. ZooKeeper介绍"></a>2. ZooKeeper介绍<br/></h1><h2 id="2-1-ZooKeeper名字的由来"><a href="#2-1-ZooKeeper名字的由来" class="headerlink" title="2.1 ZooKeeper名字的由来"></a>2.1 ZooKeeper名字的由来</h2><p>学习一样东西的时候，个人觉得最好是先了解它是怎么出现在人们眼前的，然后出现了之后是怎么慢慢地被人们使用的，使用后怎样被人们慢慢扩展的。<br>这里介绍一下它的由来（摘自《从Paxos到Zookeeper  分布式一致性原理与实践 [倪超著][电子工业出版社]》）：</p><blockquote><p>ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于 “ZooKeeper” 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：”再这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物园命名的分布式组件放在一起，雅虎整个分布式系统看上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调——于是，ZooKeeper的名字也就由此诞生了。</p></blockquote><p>看完ZooKeeper名字的由来是不是有点想笑，传奇的分布式协调框架就由此被命名了，这名字像是不要钱想的一样😂不过也能理解，开发人员都是可爱的😆</p><h2 id="2-2-ZooKeeper概述"><a href="#2-2-ZooKeeper概述" class="headerlink" title="2.2 ZooKeeper概述"></a>2.2 ZooKeeper概述</h2><p>ZooKeeper他是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><blockquote><p>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</p></blockquote><p>ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调、通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>此外，ZooKeeper将数据保存在内存中，性能是非常棒的。在”读”多于”写”的应用程序中尤其地高性能，因为”写”会导致所有的服务器进行数据同步。(“读”多于”写”是协调服务的典型场景)。</p><h2 id="2-3-ZooKeeper特点"><a href="#2-3-ZooKeeper特点" class="headerlink" title="2.3 ZooKeeper特点"></a>2.3 ZooKeeper特点</h2><ul><li>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper中去。</li><li>原子性：所有事务的请求处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功地应用了某一个事务，要么都没有应用。</li><li>单一系统映像：无论客户端连接到哪一个ZooKeeper服务器上，其看到的服务端数据模型都是一致的。</li><li>可靠性：任何一次更改请求被应用，更改的结果就会被持久化，知道被下一次更改覆盖。</li></ul><h2 id="2-4-ZooKeeper典型应用场景"><a href="#2-4-ZooKeeper典型应用场景" class="headerlink" title="2.4 ZooKeeper典型应用场景"></a>2.4 ZooKeeper典型应用场景</h2>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/fds-sunshine.github.io/2022/03/24/acwing/quicksort/"/>
    <url>/fds-sunshine.github.io/2022/03/24/acwing/quicksort/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序-如有不足之处-请各方大佬在底下批评指正"><a href="#快速排序-如有不足之处-请各方大佬在底下批评指正" class="headerlink" title="快速排序(如有不足之处, 请各方大佬在底下批评指正!!!)"></a>快速排序(如有不足之处, 请各方大佬在底下批评指正!!!)</h1><p>快速排序是从冒泡排序演变而来的算法，但是它比冒泡排序要高效得多，所以我们把它叫做快速排序😂<br>快速排序之所以快，是因为它用到了一个思想😮 ———&gt; 分治(不懂的可以百度哟😁)</p><p>那么快排是怎么实现的呢?让我们来看一下下面的图文解释:</p><h4 id="1-我们需要确定一个分界点-例如图中以标蓝的方格作为分界点7"><a href="#1-我们需要确定一个分界点-例如图中以标蓝的方格作为分界点7" class="headerlink" title="1. 我们需要确定一个分界点, 例如图中以标蓝的方格作为分界点7:"></a>1. 我们需要确定一个分界点, 例如图中以标蓝的方格作为分界点7:</h4><p> <img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/1.png"></p><h4 id="2-然后我们把小于分界点的元素放在分界点的左边-例如上图的-1-3-4-5-并且把大于分界点的元素放在分界点的右边-例如上图的-8-10-12-放置好后大概是这样的-不一定是这样-有可能是其它的情况-此时-在分界点左边的元素小于或等于分界点-在分界点右边的元素大于或等于分界点"><a href="#2-然后我们把小于分界点的元素放在分界点的左边-例如上图的-1-3-4-5-并且把大于分界点的元素放在分界点的右边-例如上图的-8-10-12-放置好后大概是这样的-不一定是这样-有可能是其它的情况-此时-在分界点左边的元素小于或等于分界点-在分界点右边的元素大于或等于分界点" class="headerlink" title="2. 然后我们把小于分界点的元素放在分界点的左边,例如上图的(1, 3, 4, 5), 并且把大于分界点的元素放在分界点的右边, 例如上图的(8, 10, 12), 放置好后大概是这样的(不一定是这样,有可能是其它的情况), 此时, 在分界点左边的元素小于或等于分界点, 在分界点右边的元素大于或等于分界点:"></a>2. 然后我们把<strong>小于分界点</strong>的元素放在分界点的左边,例如上图的(1, 3, 4, 5), 并且把<strong>大于分界点</strong>的元素放在分界点的右边, 例如上图的(8, 10, 12), 放置好后大概是这样的(不一定是这样,有可能是其它的情况), 此时, 在<strong>分界点</strong>左边的元素<strong>小于或等于</strong>分界点, 在<strong>分界点</strong>右边的元素<strong>大于或等于</strong>分界点:</h4><p><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/2.png"></p><h4 id="3-利用分界点分好两边的元素后-得到下面的三个部分-我们分别对左边的部分与右边的部分分别进行1与2的操作-最后便可以排好序了-下图演示"><a href="#3-利用分界点分好两边的元素后-得到下面的三个部分-我们分别对左边的部分与右边的部分分别进行1与2的操作-最后便可以排好序了-下图演示" class="headerlink" title="3. 利用分界点分好两边的元素后,得到下面的三个部分, 我们分别对左边的部分与右边的部分分别进行1与2的操作, 最后便可以排好序了(下图演示):"></a>3. 利用<strong>分界点</strong>分好两边的元素后,得到下面的三个部分, 我们分别对<strong>左边的部分</strong>与<strong>右边的部分</strong>分别进行1与2的操作, 最后便可以排好序了(下图演示):</h4><p><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/3.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/4.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/5.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/6.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/7.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/8.png"></p><blockquote><p>到这里, 这个数组便已经排好序了</p></blockquote><h4 id="4-这时候就进入我们紧张刺激的代码环节"><a href="#4-这时候就进入我们紧张刺激的代码环节" class="headerlink" title="4. 这时候就进入我们紧张刺激的代码环节:"></a>4. 这时候就进入我们紧张刺激的代码环节:</h4><h5 id="4-1-Java代码"><a href="#4-1-Java代码" class="headerlink" title="4.1 Java代码"></a>4.1 Java代码</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//1.确定分界点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//2.确定分界点左边的元素</span><br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(i &lt; x);<br>    <span class="hljs-comment">//3.确定分界点右边的元素</span><br>    <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(j &gt; x);<br>    <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>    <span class="hljs-comment">//有代码整洁洁癖的童鞋可以把if里面的代码写成一个方法,然后在进行调用</span><br>    <span class="hljs-keyword">if</span>(i &lt; j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>    <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>    quick_sort(arr, l, j);<br>    <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>    quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-2-C代码"><a href="#4-2-C代码" class="headerlink" title="4.2 C代码"></a>4.2 C代码</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//1.确定分界点</span><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//2.确定分界点左边的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>        <span class="hljs-comment">//3.确定分界点右边的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) <br>        &#123;<br>            <span class="hljs-type">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;;<br>        <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>        quick_sort(arr, l, j);<br>        <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>        quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-3-C-代码"><a href="#4-3-C-代码" class="headerlink" title="4.3 C++代码"></a>4.3 C++代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//1.确定分界点</span><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//2.确定分界点左边的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>        <span class="hljs-comment">//3.确定分界点右边的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, l, j);<br>        <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-4-Python代码-语法忘记-后续更新"><a href="#4-4-Python代码-语法忘记-后续更新" class="headerlink" title="4.4 Python代码(语法忘记, 后续更新)"></a>4.4 Python代码(语法忘记, 后续更新)</h5><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr, l, r</span>):<br>    i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><h5 id="4-5-Go代码-后续更新"><a href="#4-5-Go代码-后续更新" class="headerlink" title="4.5 Go代码(后续更新)"></a>4.5 Go代码(后续更新)</h5><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>acwing算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
