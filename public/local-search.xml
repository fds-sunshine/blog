<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一、zookeeper入门</title>
    <link href="/fds-sunshine.github.io/2022/03/25/zookeeper/zookeeper%E5%85%A5%E9%97%A8/"/>
    <url>/fds-sunshine.github.io/2022/03/25/zookeeper/zookeeper%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言<br/></h1><p>在此刻的我并不知道zookeeper是什么，我听到zookeeper的第一感觉就是这家伙是啥啊，对的，前言就这么短，因为我也不知道它是啥，也没怎么用。</p><h1 id="2-ZooKeeper介绍"><a href="#2-ZooKeeper介绍" class="headerlink" title="2. ZooKeeper介绍"></a>2. ZooKeeper介绍<br/></h1><h2 id="2-1-ZooKeeper名字的由来"><a href="#2-1-ZooKeeper名字的由来" class="headerlink" title="2.1 ZooKeeper名字的由来"></a>2.1 ZooKeeper名字的由来</h2><p>学习一样东西的时候，个人觉得最好是先了解它是怎么出现在人们眼前的，然后出现了之后是怎么慢慢地被人们使用的，使用后怎样被人们慢慢扩展的。<br>这里介绍一下它的由来（摘自《从Paxos到Zookeeper  分布式一致性原理与实践 [倪超著][电子工业出版社]》）：</p><blockquote><p>ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于 “ZooKeeper” 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：”再这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物园命名的分布式组件放在一起，雅虎整个分布式系统看上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调——于是，ZooKeeper的名字也就由此诞生了。</p></blockquote><p>看完ZooKeeper名字的由来是不是有点想笑，传奇的分布式协调框架就由此被命名了，这名字像是不要钱想的一样😂不过也能理解，开发人员都是可爱的😆</p><h2 id="2-2-ZooKeeper概述"><a href="#2-2-ZooKeeper概述" class="headerlink" title="2.2 ZooKeeper概述"></a>2.2 ZooKeeper概述</h2><p>ZooKeeper他是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><blockquote><p>原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。</p></blockquote><p>ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调、通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>此外，ZooKeeper将数据保存在内存中，性能是非常棒的。在”读”多于”写”的应用程序中尤其地高性能，因为”写”会导致所有的服务器进行数据同步。(“读”多于”写”是协调服务的典型场景)。</p><h2 id="2-3-ZooKeeper特点"><a href="#2-3-ZooKeeper特点" class="headerlink" title="2.3 ZooKeeper特点"></a>2.3 ZooKeeper特点</h2><ul><li><strong>顺序一致性</strong>：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper中去。</li><li><strong>原子性</strong>：所有事务的请求处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功地应用了某一个事务，要么都没有应用。</li><li><strong>单一系统映像</strong>：无论客户端连接到哪一个ZooKeeper服务器上，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>：任何一次更改请求被应用，更改的结果就会被持久化，知道被下一次更改覆盖。</li></ul><h2 id="2-4-ZooKeeper典型应用场景"><a href="#2-4-ZooKeeper典型应用场景" class="headerlink" title="2.4 ZooKeeper典型应用场景"></a>2.4 ZooKeeper典型应用场景</h2><p>ZooKeeper概述中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p><p>下面选3个典型的应用场景来专门说说(后续更新具体代码逻辑)：</p><ol><li><strong>分布式锁</strong>：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放。</li><li><strong>命名服务</strong>：可以通过ZooKeeper的顺序节点生成全局唯一ID。</li><li><strong>数据发布/订阅</strong>：通过Watcher机制可以很方便地实现数据发布/订阅。当你将数据发布到ZooKeeper被监听的节点上，其他机器可通过监听ZooKeeper上的节点的变化来实现配置的动态更新。</li></ol><p>实际上，这些功能的实现基本上都得益于ZooKeeper可以保存数据的功能，但是ZooKeeper不适合保存大量数据，这一点需要注意一下😤</p><h1 id="3-ZooKeeper的功能"><a href="#3-ZooKeeper的功能" class="headerlink" title="3. ZooKeeper的功能"></a>3. ZooKeeper的功能<br/></h1><p>友情提示👿：拿出小本本，下面的内容非常重要啊哈</p><h2 id="3-1-Data-model（数据模型）"><a href="#3-1-Data-model（数据模型）" class="headerlink" title="3.1 Data model（数据模型）"></a>3.1 Data model（数据模型）</h2><p>ZooKeeper数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数字可以说是数字、字符串或者是二进制序列。并且，每个节点还可以拥有N个子节点，最上层是根节点使用”/“来表示。每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最先单元。并且，每个znode都只有一个唯一的路径标识。</p><p>强调一句👿：<strong>ZooKeeper主要是用来协调服务，而不是用来存储业务数据的，所以，不要放比较大的数据在znode上，ZooKeeper给出的上线是每个结点的数据大小最大是1M。</strong></p><p>从下图可以更直观地看出：ZooKeeper节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用”/“进行分割的路径表示，开发人员可以想这个结点中写入数据，也可以在节点下面创建子节点。<br>这些操作后面我们来实操一下。<br><img src="https://javaguide.cn/assets/znode-structure.19119dbd.png"></p><h2 id="3-2-znode（数据节点）"><a href="#3-2-znode（数据节点）" class="headerlink" title="3.2 znode（数据节点）"></a>3.2 znode（数据节点）</h2><p>介绍了ZooKeeper树形数据模型之后，我们知道每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最小单元。你要存放的数据就放在上面，是你使用ZooKeeper过程中经常需要接触到的一个概念。</p><h3 id="3-2-1-znode的4中类型"><a href="#3-2-1-znode的4中类型" class="headerlink" title="3.2.1 znode的4中类型"></a>3.2.1 znode的4中类型</h3><p>一般我们将znode分为4大类：</p><ul><li><strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使ZooKeeper集群宕机，直到将其删除。</li><li><strong>临时（EPHEMERAL）节点</strong>：临时结点的生命周期是与<strong>客户端会话（session）</strong>绑定的，<strong>会话消失则结点消失</strong>。并且<strong>临时结点只能做叶子结点</strong>，不能创建子节点。</li><li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外，子节点的名称还具有顺序性。比如<code>/node1/00000000001</code>、<code>/node/00000000002</code>。</li><li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><h3 id="3-2-2-znode数据结构"><a href="#3-2-2-znode数据结构" class="headerlink" title="3.2.2 znode数据结构"></a>3.2.2 znode数据结构</h3><p>每个znode由2部分组成：</p><ul><li><strong>stat</strong>：状态信息。</li><li><strong>data</strong>：节点存放的数据的具体内容。</li></ul><p>如下所示，我通过ZooKeeper的get命令来获取根目录下violet节点的内容。（get命令在下面会详细介绍哟）。</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">[zk: 127.0.0.1:2181(CONNECTED) 6] get /violet<br><span class="hljs-comment"># 该数据节点关联的数据内容为空</span><br>null<br><span class="hljs-comment"># 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span><br>cZxid = 0x2<br>ctime = Tue Nov 27 18:05:34 CST 2022<br>mZxid = 0x2<br>mtime = Tue Nov 27 18:05:34 CST 2022<br>pZxid = 0x3<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 0<br>numChildren = 1<br></code></pre></div></td></tr></table></figure><p>Stat类中包含了一个数据节点的所有状态信息的字段，包括事务ID-cZxid、节点创建时间-ctime和子节点个数-numChidren等等。</p><p>下面我们来看一下每个znode状态信息究竟代表的是什么吧！（下面的内容来源于《从Paxos到Zookeeper  分布式一致性原理与实践》，因为松松也不是特别清楚，要学会参考资料哟）：</p><table><thead><tr><th><strong>znode状态信息</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>cZxid</td><td>create ZXID，即该数据节点被创建时的事务id</td></tr><tr><td>ctime</td><td>create time, 即该节点的创建时间</td></tr><tr><td>mZxid</td><td>modified ZXID，即该节点最终一次更新时的事务id</td></tr><tr><td>mtime</td><td>modified time，即该节点最后一次的更新时间</td></tr><tr><td>pZxid</td><td>该节点的子节点列表最后一次修改时的事务id，只有子节点列表变更才会更新pZxid，子节点内容变更不会更新</td></tr><tr><td>cversion</td><td>子节点版本号，当前节点的子节点每次变化时值增加1</td></tr><tr><td>dataVersion</td><td>数据节点内容版本号，节点创建时为0，每更新一次节点内容（不管内容有无变化）该版本号的值增加1</td></tr><tr><td>aclVersion</td><td>节点的ACL版本号，表示该节点ACL信息变更次数</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的sessionid：如果当前节点为持久节点，则ephemeralOwner=0</td></tr><tr><td>dataLength</td><td>数据节点内容长度</td></tr><tr><td>numChildren</td><td>当前节点的子节点个数</td></tr></tbody></table><h2 id="3-3-版本（version）"><a href="#3-3-版本（version）" class="headerlink" title="3.3 版本（version）"></a>3.3 版本（version）</h2><p>在前面我们已经提到，对应每个znode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个znode的三个相关的版本：</p><ul><li><strong>dataVersion</strong>：当前znode节点的版本号。</li><li><strong>cversion</strong>：当前znode子节点的版本。</li><li><strong>aclVersion</strong>：当前znode的ACL的版本号。</li></ul><h2 id="3-4-ACL（权限控制）"><a href="#3-4-ACL（权限控制）" class="headerlink" title="3.4 ACL（权限控制）"></a>3.4 ACL（权限控制）</h2><p>ZooKeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于UNIX文件系统的权限控制。</p><p>对于znode操作的权限，ZooKeeper提供了以下5种：</p><ul><li><strong>CREATE</strong>：能创建子节点</li><li><strong>READ</strong>：能获取节点数据和列出其子节点</li><li><strong>WRITE</strong>：能设置/更新节点数据</li><li><strong>DELETE</strong>：能删除子节点</li><li><strong>ADMIN</strong>: 能设置节点ACL的权限</li></ul><p>其中尤其需要注意的是， CREATE和DELETE这两种权限都是针对子节点的权限控制。</p><p>对于身份认证，提供了以下几种方式：</p><ul><li><strong>world</strong>：默认方式，所有用户都可无条件访问。</li><li><strong>auth</strong>：不适用任何id，代表任何已认证的用户。</li><li><strong>digest</strong>：用户名：密码认证方式：username:password。</li><li><strong>ip</strong>：对指定ip进行限制。</li></ul><h2 id="3-5-Watcher（事件监听器）"><a href="#3-5-Watcher（事件监听器）" class="headerlink" title="3.5 Watcher（事件监听器）"></a>3.5 Watcher（事件监听器）</h2><p>Watcher（事件监听器），是ZooKeeper中的一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。<br><img src="https://javaguide.cn/assets/watche%E6%9C%BA%E5%88%B6.f523bd89.png"><br>王之怒吼👿：非常有用的一个特性，都拿出小本本记好了，后面用到ZooKeeper基本离不开Watcher（事件监听）机制。</p><h2 id="3-6-会话（Session）"><a href="#3-6-会话（Session）" class="headerlink" title="3.6 会话（Session）"></a>3.6 会话（Session）</h2>]]></content>
    
    
    <categories>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/fds-sunshine.github.io/2022/03/24/acwing/quicksort/"/>
    <url>/fds-sunshine.github.io/2022/03/24/acwing/quicksort/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序-如有不足之处-请各方大佬在底下批评指正"><a href="#快速排序-如有不足之处-请各方大佬在底下批评指正" class="headerlink" title="快速排序(如有不足之处, 请各方大佬在底下批评指正!!!)"></a>快速排序(如有不足之处, 请各方大佬在底下批评指正!!!)</h1><p>快速排序是从冒泡排序演变而来的算法，但是它比冒泡排序要高效得多，所以我们把它叫做快速排序😂<br>快速排序之所以快，是因为它用到了一个思想😮 ———&gt; 分治(不懂的可以百度哟😁)</p><p>那么快排是怎么实现的呢?让我们来看一下下面的图文解释:</p><h4 id="1-我们需要确定一个分界点-例如图中以标蓝的方格作为分界点7"><a href="#1-我们需要确定一个分界点-例如图中以标蓝的方格作为分界点7" class="headerlink" title="1. 我们需要确定一个分界点, 例如图中以标蓝的方格作为分界点7:"></a>1. 我们需要确定一个分界点, 例如图中以标蓝的方格作为分界点7:</h4><p> <img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/1.png"></p><h4 id="2-然后我们把小于分界点的元素放在分界点的左边-例如上图的-1-3-4-5-并且把大于分界点的元素放在分界点的右边-例如上图的-8-10-12-放置好后大概是这样的-不一定是这样-有可能是其它的情况-此时-在分界点左边的元素小于或等于分界点-在分界点右边的元素大于或等于分界点"><a href="#2-然后我们把小于分界点的元素放在分界点的左边-例如上图的-1-3-4-5-并且把大于分界点的元素放在分界点的右边-例如上图的-8-10-12-放置好后大概是这样的-不一定是这样-有可能是其它的情况-此时-在分界点左边的元素小于或等于分界点-在分界点右边的元素大于或等于分界点" class="headerlink" title="2. 然后我们把小于分界点的元素放在分界点的左边,例如上图的(1, 3, 4, 5), 并且把大于分界点的元素放在分界点的右边, 例如上图的(8, 10, 12), 放置好后大概是这样的(不一定是这样,有可能是其它的情况), 此时, 在分界点左边的元素小于或等于分界点, 在分界点右边的元素大于或等于分界点:"></a>2. 然后我们把<strong>小于分界点</strong>的元素放在分界点的左边,例如上图的(1, 3, 4, 5), 并且把<strong>大于分界点</strong>的元素放在分界点的右边, 例如上图的(8, 10, 12), 放置好后大概是这样的(不一定是这样,有可能是其它的情况), 此时, 在<strong>分界点</strong>左边的元素<strong>小于或等于</strong>分界点, 在<strong>分界点</strong>右边的元素<strong>大于或等于</strong>分界点:</h4><p><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/2.png"></p><h4 id="3-利用分界点分好两边的元素后-得到下面的三个部分-我们分别对左边的部分与右边的部分分别进行1与2的操作-最后便可以排好序了-下图演示"><a href="#3-利用分界点分好两边的元素后-得到下面的三个部分-我们分别对左边的部分与右边的部分分别进行1与2的操作-最后便可以排好序了-下图演示" class="headerlink" title="3. 利用分界点分好两边的元素后,得到下面的三个部分, 我们分别对左边的部分与右边的部分分别进行1与2的操作, 最后便可以排好序了(下图演示):"></a>3. 利用<strong>分界点</strong>分好两边的元素后,得到下面的三个部分, 我们分别对<strong>左边的部分</strong>与<strong>右边的部分</strong>分别进行1与2的操作, 最后便可以排好序了(下图演示):</h4><p><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/3.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/4.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/5.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/6.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/7.png"><br><img src="https://gitee.com/violet-bug/imageurl/raw/master/acwing/quicksort/8.png"></p><blockquote><p>到这里, 这个数组便已经排好序了</p></blockquote><h4 id="4-这时候就进入我们紧张刺激的代码环节"><a href="#4-这时候就进入我们紧张刺激的代码环节" class="headerlink" title="4. 这时候就进入我们紧张刺激的代码环节:"></a>4. 这时候就进入我们紧张刺激的代码环节:</h4><h5 id="4-1-Java代码"><a href="#4-1-Java代码" class="headerlink" title="4.1 Java代码"></a>4.1 Java代码</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//1.确定分界点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//2.确定分界点左边的元素</span><br>    <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(i &lt; x);<br>    <span class="hljs-comment">//3.确定分界点右边的元素</span><br>    <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(j &gt; x);<br>    <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>    <span class="hljs-comment">//有代码整洁洁癖的童鞋可以把if里面的代码写成一个方法,然后在进行调用</span><br>    <span class="hljs-keyword">if</span>(i &lt; j) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>    <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>    quick_sort(arr, l, j);<br>    <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>    quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-2-C代码"><a href="#4-2-C代码" class="headerlink" title="4.2 C代码"></a>4.2 C代码</h5><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//1.确定分界点</span><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//2.确定分界点左边的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>        <span class="hljs-comment">//3.确定分界点右边的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) <br>        &#123;<br>            <span class="hljs-type">int</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;;<br>        <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>        quick_sort(arr, l, j);<br>        <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>        quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-3-C-代码"><a href="#4-3-C-代码" class="headerlink" title="4.3 C++代码"></a>4.3 C++代码</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//1.确定分界点</span><br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//2.确定分界点左边的元素</span><br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(arr[i] &lt; x);<br>        <span class="hljs-comment">//3.确定分界点右边的元素</span><br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(arr[j] &gt; x);<br>        <span class="hljs-comment">//4.交换元素以便把小于分界点的元素放到左边, 大于分界点的元素放到右边</span><br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        <span class="hljs-comment">//5.递归处理分界点左边的元素</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, l, j);<br>        <span class="hljs-comment">//6.递归处理分界点右边的元素</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-4-Python代码-语法忘记-后续更新"><a href="#4-4-Python代码-语法忘记-后续更新" class="headerlink" title="4.4 Python代码(语法忘记, 后续更新)"></a>4.4 Python代码(语法忘记, 后续更新)</h5><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr, l, r</span>):<br>    i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = arr[l + r &gt;&gt; <span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><h5 id="4-5-Go代码-后续更新"><a href="#4-5-Go代码-后续更新" class="headerlink" title="4.5 Go代码(后续更新)"></a>4.5 Go代码(后续更新)</h5><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>acwing算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
