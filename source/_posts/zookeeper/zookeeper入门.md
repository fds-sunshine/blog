---
title: 一、zookeeper入门
date: 2022-03-25 11:09:47
tags: zookeeper
category: zookeeper
description: 介绍zookeeper的入门概念、数据模型、应用场景以及Java对它进行整合。
---
# 1. 前言<br/>
在此刻的我并不知道zookeeper是什么，我听到zookeeper的第一感觉就是这家伙是啥啊，对的，前言就这么短，因为我也不知道它是啥，也没怎么用。
# 2. ZooKeeper介绍<br/>
## 2.1 ZooKeeper名字的由来
学习一样东西的时候，个人觉得最好是先了解它是怎么出现在人们眼前的，然后出现了之后是怎么慢慢地被人们使用的，使用后怎样被人们慢慢扩展的。
这里介绍一下它的由来（摘自《从Paxos到Zookeeper  分布式一致性原理与实践 [倪超著][电子工业出版社]》）：
> ZooKeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于 "ZooKeeper" 这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目），雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说："再这样下去，我们这儿就变成动物园了！"此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物园命名的分布式组件放在一起，雅虎整个分布式系统看上去就像一个大型的动物园了，而ZooKeeper正好要用来进行分布式环境的协调——于是，ZooKeeper的名字也就由此诞生了。

看完ZooKeeper名字的由来是不是有点想笑，传奇的分布式协调框架就由此被命名了，这名字像是不要钱想的一样😂不过也能理解，开发人员都是可爱的😆

## 2.2 ZooKeeper概述
ZooKeeper他是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。
> 原语：一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。

ZooKeeper为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调、通知、集群管理、Master选举、分布式锁和分布式队列等功能。

此外，ZooKeeper将数据保存在内存中，性能是非常棒的。在"读"多于"写"的应用程序中尤其地高性能，因为"写"会导致所有的服务器进行数据同步。("读"多于"写"是协调服务的典型场景)。

## 2.3 ZooKeeper特点
- **顺序一致性**：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到ZooKeeper中去。
- **原子性**：所有事务的请求处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功地应用了某一个事务，要么都没有应用。
- **单一系统映像**：无论客户端连接到哪一个ZooKeeper服务器上，其看到的服务端数据模型都是一致的。
- **可靠性**：任何一次更改请求被应用，更改的结果就会被持久化，知道被下一次更改覆盖。

## 2.4 ZooKeeper典型应用场景

ZooKeeper概述中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。

下面选3个典型的应用场景来专门说说(后续更新具体代码逻辑)：
1. **分布式锁**：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放。
2. **命名服务**：可以通过ZooKeeper的顺序节点生成全局唯一ID。
3. **数据发布/订阅**：通过Watcher机制可以很方便地实现数据发布/订阅。当你将数据发布到ZooKeeper被监听的节点上，其他机器可通过监听ZooKeeper上的节点的变化来实现配置的动态更新。

实际上，这些功能的实现基本上都得益于ZooKeeper可以保存数据的功能，但是ZooKeeper不适合保存大量数据，这一点需要注意一下😤

# 3. ZooKeeper的功能<br/>
友情提示👿：拿出小本本，下面的内容非常重要啊哈

## 3.1 Data model（数据模型）
ZooKeeper数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数字可以说是数字、字符串或者是二进制序列。并且，每个节点还可以拥有N个子节点，最上层是根节点使用"/"来表示。每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最先单元。并且，每个znode都只有一个唯一的路径标识。

强调一句👿：**ZooKeeper主要是用来协调服务，而不是用来存储业务数据的，所以，不要放比较大的数据在znode上，ZooKeeper给出的上线是每个结点的数据大小最大是1M。**

从下图可以更直观地看出：ZooKeeper节点路径标识方式和Unix文件系统路径非常相似，都是由一系列使用"/"进行分割的路径表示，开发人员可以想这个结点中写入数据，也可以在节点下面创建子节点。
这些操作后面我们来实操一下。
![](https://javaguide.cn/assets/znode-structure.19119dbd.png)

## 3.2 znode（数据节点）
介绍了ZooKeeper树形数据模型之后，我们知道每个数据节点在ZooKeeper中被称为znode，它是ZooKeeper中数据的最小单元。你要存放的数据就放在上面，是你使用ZooKeeper过程中经常需要接触到的一个概念。

### 3.2.1 znode的4中类型
一般我们将znode分为4大类：
- **持久（PERSISTENT）节点**：一旦创建就一直存在即使ZooKeeper集群宕机，直到将其删除。
- **临时（EPHEMERAL）节点**：临时结点的生命周期是与**客户端会话（session）**绑定的，**会话消失则结点消失**。并且**临时结点只能做叶子结点**，不能创建子节点。
- **持久顺序（PERSISTENT_SEQUENTIAL）节点**：除了具有持久（PERSISTENT）节点的特性之外，子节点的名称还具有顺序性。比如```/node1/00000000001```、```/node/00000000002```。
- **临时顺序（EPHEMERAL_SEQUENTIAL）节点**：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。

### 3.2.2 znode数据结构
每个znode由2部分组成：
- **stat**：状态信息。
- **data**：节点存放的数据的具体内容。

如下所示，我通过ZooKeeper的get命令来获取根目录下violet节点的内容。（get命令在下面会详细介绍哟）。
```sh
[zk: 127.0.0.1:2181(CONNECTED) 6] get /violet
# 该数据节点关联的数据内容为空
null
# 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出
cZxid = 0x2
ctime = Tue Nov 27 18:05:34 CST 2022
mZxid = 0x2
mtime = Tue Nov 27 18:05:34 CST 2022
pZxid = 0x3
cversion = 1
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 1
```

Stat类中包含了一个数据节点的所有状态信息的字段，包括事务ID-cZxid、节点创建时间-ctime和子节点个数-numChidren等等。

下面我们来看一下每个znode状态信息究竟代表的是什么吧！（下面的内容来源于《从Paxos到Zookeeper  分布式一致性原理与实践》，因为松松也不是特别清楚，要学会参考资料哟）：

| **znode状态信息**|**解释**|
|--|--|
| cZxid|create ZXID，即该数据节点被创建时的事务id|
|ctime|create time, 即该节点的创建时间|
|mZxid|modified ZXID，即该节点最终一次更新时的事务id|
|mtime|modified time，即该节点最后一次的更新时间|
|pZxid|该节点的子节点列表最后一次修改时的事务id，只有子节点列表变更才会更新pZxid，子节点内容变更不会更新|
|cversion|子节点版本号，当前节点的子节点每次变化时值增加1|
|dataVersion|数据节点内容版本号，节点创建时为0，每更新一次节点内容（不管内容有无变化）该版本号的值增加1|
|aclVersion|节点的ACL版本号，表示该节点ACL信息变更次数|
|ephemeralOwner|创建该临时节点的会话的sessionid：如果当前节点为持久节点，则ephemeralOwner=0|
|dataLength|数据节点内容长度|
|numChildren|当前节点的子节点个数|

## 3.3 版本（version）
在前面我们已经提到，对应每个znode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个znode的三个相关的版本：
- **dataVersion**：当前znode节点的版本号。
- **cversion**：当前znode子节点的版本。
- **aclVersion**：当前znode的ACL的版本号。

## 3.4 ACL（权限控制）
ZooKeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于UNIX文件系统的权限控制。

对于znode操作的权限，ZooKeeper提供了以下5种：
- **CREATE**：能创建子节点
- **READ**：能获取节点数据和列出其子节点
- **WRITE**：能设置/更新节点数据
- **DELETE**：能删除子节点
- **ADMIN**: 能设置节点ACL的权限

其中尤其需要注意的是， CREATE和DELETE这两种权限都是针对子节点的权限控制。

对于身份认证，提供了以下几种方式：
- **world**：默认方式，所有用户都可无条件访问。
- **auth**：不适用任何id，代表任何已认证的用户。
- **digest**：用户名：密码认证方式：username:password。
- **ip**：对指定ip进行限制。

## 3.5 Watcher（事件监听器）
Watcher（事件监听器），是ZooKeeper中的一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。
![](https://javaguide.cn/assets/watche%E6%9C%BA%E5%88%B6.f523bd89.png)
王之怒吼👿：非常有用的一个特性，都拿出小本本记好了，后面用到ZooKeeper基本离不开Watcher（事件监听）机制。

## 3.6 会话（Session）
